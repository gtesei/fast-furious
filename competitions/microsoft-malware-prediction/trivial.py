# -*- Coding: utf-8 -*-
import pandas as pd 
import numpy as np 
import matplotlib.pyplot as plt 
from sklearn.preprocessing import LabelEncoder
import re 
from sklearn.feature_extraction import DictVectorizer
from sklearn.model_selection import train_test_split
import pandas as pd
from pandas.tseries.holiday import USFederalHolidayCalendar as calendar 
import pandas as pd
import numpy as np
import lightgbm as lgb
#import xgboost as xgb
from scipy.sparse import vstack, csr_matrix, save_npz, load_npz
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.model_selection import StratifiedKFold
#from sklearn.metrics import roc_auc_score
import gc
import sys 
gc.enable()

    
### FUNC ########################################################################
def get_xgb_imp(xgb, feat_names):
    from numpy import array
    imp_vals = xgb.booster().get_fscore()
    imp_dict = {feat_names[i]:float(imp_vals.get('f'+str(i),0.)) for i in range(len(feat_names))}
    total = array(imp_dict.values()).sum()
    return {k:v/total for k,v in imp_dict.items()}


def xgb_feat_importance(model,cols,file_name):
    print('-----> Feature importance ... ')
    feature_importance_dict = model.get_fscore()
    fs = ['f%i' % i for i in range(len(cols))]
    f1 = pd.DataFrame({'f': list(feature_importance_dict.keys()), 'importance': list(feature_importance_dict.values())})
    f2 = pd.DataFrame({'f': fs, 'feature_name': cols})
    feature_importance = pd.merge(f1, f2, how='right', on='f')
    feature_importance = feature_importance.fillna(0)
    feature_importance.sort_values(by='importance', ascending=False)
    print(feature_importance.sort_values)
    feature_importance.to_csv(file_name, index=False)

def add_avg_per(df,what_to_avg,on,new_name,include_delta=True,include_perc=True):
    if type(on) == str:
        _full = [on,what_to_avg]
        _fulla = [on,new_name]
    elif type(on) == list:
        _full = on.copy()
        _full.append(what_to_avg)
        _fulla = on.copy()
        _fulla.append(new_name)
    else:
        raise Exception('what type is on!')
    _avg = df.groupby(on)[_full].mean()
    _avg.columns = _fulla
    prev_len = len(df)
    df = df.merge(_avg,how='inner' , on=on)
    assert len(df) == prev_len
    if include_delta:
        df[str(new_name+'_delta')] = df[what_to_avg] - df[new_name]
    if include_perc:
        df[str(new_name+'_perc')] = (df[what_to_avg] - df[new_name])/df[new_name]
    return df 
        
def encode_dataset(train,test,meta,target_model='lgb'):
    y_train = train[meta['target']]
    train = train.drop([meta['target']],axis=1)
    assert train.shape[1] == test.shape[1]
    for i in range(train.shape[1]):
        assert train.columns[i] == test.columns[i]
    train_obs = len(train)
    #
    for i,usecol in enumerate(train.columns.tolist()[1:-1]):
        if usecol in ['Census_PrimaryDiskTotalCapacity','Census_SystemVolumeTotalCapacity',
                      'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                      'Census_InternalBatteryNumberOfCharges','Census_OSBuildNumber']:
            print(i,usecol,"NUM")
            train[usecol].fillna(-1)
            test[usecol].fillna(-1)
        else:
            print(i,usecol,"CAT")
            train[usecol] = train[usecol].astype('str')
            test[usecol] = test[usecol].astype('str')
            #Fit LabelEncoder
            le = LabelEncoder().fit(np.unique(train[usecol].unique().tolist()+test[usecol].unique().tolist()))
            #At the end 0 will be used for dropped values
            train[usecol] = le.transform(train[usecol])+1
            test[usecol]  = le.transform(test[usecol])+1
            agg_tr = (train.groupby([usecol])
                      .aggregate({'MachineIdentifier':'count'})
                      .reset_index()
                      .rename({'MachineIdentifier':'Train'}, axis=1))
            agg_te = (test.groupby([usecol])
                      .aggregate({'MachineIdentifier':'count'})
                      .reset_index()
                      .rename({'MachineIdentifier':'Test'}, axis=1))
            agg = pd.merge(agg_tr, agg_te, on=usecol, how='outer').replace(np.nan, 0)
            #Select values with more than 1000 observations
            agg = agg[(agg['Train'] > 1000)].reset_index(drop=True)
            agg['Total'] = agg['Train'] + agg['Test']
            #Drop unbalanced values
            agg = agg[(agg['Train'] / agg['Total'] > 0.2) & (agg['Train'] / agg['Total'] < 0.8)]
            agg[usecol+'Copy'] = agg[usecol]
            train[usecol] = (pd.merge(train[[usecol]],agg[[usecol, usecol+'Copy']],on=usecol, how='left')[usecol+'Copy'].replace(np.nan, 0).astype('int').astype('category'))
            test[usecol]  = (pd.merge(test[[usecol]],agg[[usecol, usecol+'Copy']],on=usecol, how='left')[usecol+'Copy'].replace(np.nan, 0).astype('int').astype('category'))
    assert train_obs == len(y_train)
    return train , test, y_train
#################################################################################    
dtypes = {
        'MachineIdentifier':                                    'str',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        'HasDetections':                                        'int8'
        }


print('Download Train and Test Data.\n')
DEBUG = False
if DEBUG:
    print(">>> Debug mode ... ")
    train = pd.read_csv('data/train_sample.csv', dtype=dtypes, low_memory=True)
    #train['MachineIdentifier'] = train.index.astype('str')
    test  = pd.read_csv('data/test_sample.csv',  dtype=dtypes, low_memory=True)
    #test['MachineIdentifier']  = test.index.astype('str')
    gc.collect()
else:
    print(">>> Production mode ... ")
    train = pd.read_csv('data/train.csv', dtype=dtypes, low_memory=True)
    #train['MachineIdentifier'] = train.index.astype('uint32')
    test  = pd.read_csv('data/test.csv',  dtype=dtypes, low_memory=True)
    #test['MachineIdentifier']  = test.index.astype('uint32')
    gc.collect()


print(">> Train:",train.shape)
print(">> Test:", test.shape)

inter = pd.merge(train,test,on='MachineIdentifier',how='inner')
print("intersect:",inter.shape)
print(inter.head())
#print(">>>>> cols <<<<")
#for i, col in enumerate(inter.columns.tolist()):
#    print(i,col)
sub = inter[['MachineIdentifier','HasDetections']]
print("********")
print(sub.head())
sub.to_csv('sub3.csv', index=False)

print('\nDone.')
